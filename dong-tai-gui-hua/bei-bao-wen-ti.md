# 背包问题

## 01背包问题

### 问题定义

有 $$N$$ 件物品和容量为 $$V$$ 的背包，第 $$i$$ 个物品的代价是 $$c[i]$$ ，价值是 $$w[i]$$ ，每个物品只能装入一次，求解装入那些物品总价值最大。

### 状态转移方程

对第 $$i$$ 件物品做选择，当容量剩余为 $$j$$ 时：如果放入第 $$i$$ 件物品，则接下来将考虑 $$[0..i-1]$$ 件物品放入容量为 $$j-c[i]$$ 的背包中的最大总价值，此时背包中的价值多了 $$w[i]$$ ；如果不放入第 $$i$$ 件物品，则接下来将考虑 $$[0..i-1]$$ 件物品放入容量为 $$j$$ 的背包中的最大总价值。最终取：

$$
f[i][j]=max\{f[i-1][j],f[i-1][j-c[i]+w[i]]\}
$$

#### **举例**

物品代价： $$[1,2,5]$$ ，物品价值： $$[2,1,3]$$ ，背包容量： $$8$$ 

|  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 | 0 | 2 | 2 | 3 | 3 | 3 | 5 | 5 | 6 |
| 2 | 0 | 2 | 2 | 3 | 3 | 3 | 5 | 5 | 6 |
| 3 | 0 | 2 | 2 | 3 | 3 | 3 | 5 | 5 | 6 |

实际上当前一行的值只与上一行的值有关，所以可以只申请一维数组，不断更新。

### 空间优化

上一例中的空间复杂度为 $$O(NV)$$ ，实际上只需要申请 $$V+1$$ 大小的数组，以物品作为外循环，最终要求的结果在 $$f[N][V]$$ 。

$$
f[j]=max\{f[j],f[j-c[i]]+w[i]\}
$$

```cpp
for i=1...N
    for j=V...0
        f[j] = max{f[j], f[j-c[i]] + w[i]}
```

进一步优化：对于第 $$i$$ 个物品，若当前的剩余容量 $$j$$ 比该物品的代价 $$cost[i]$$ 还要小，那么只有“不放入物品 $$i$$ ”一种选择，所以不会影响到容量为 $$[0...cost[i]-1]$$ 这个区间的值。

```cpp
for i=i...N
    for j=V...cost[i]
        f[j] = max{f[j], f[j-c[i]] + w[i]}
```

#### **细节**

* 初始化

当题目要求“恰好装满背包”时，初始化只有容量为 $$0$$ 对应的值为 $$0$$ ，其它全为无效值（若要求最大价值则设为 $$-\infty$$ ，若要求最小价值则设为 $$+\infty$$ ）。

当题目没有要求“恰好装满背包”时，初始化所有位置都为 $$0$$ ，因为最差的情况就是什么都不放。

* 背包问题转换

**其它背包问题实际上都能通过将同类物品拆分成多个（题目限制个数）转化为01背包问题：**

**（直接拆分）**对于第$i$种物品，若其件数为 $$n$$ （即第 $$i$$ 种物品可重复被取 $$n$$ 次），则将其拆分为 $$n$$ 个代价为 $$c[n]$$ 价值为 $$w[n]$$ 的物品，这些物品显然最多只能选一次。最终拆分为 $$n$$ 件子物品。

**（二进制拆分）**对于第 $$i$$ 种物品，若其件数为 $$n$$ （即第 $$i$$ 种物品可重复被取 $$n$$ 次），则将其拆分为（代价，价值）为 $$(c[i],w[i])$$ ； $$(2c[i],2w[i])$$ ； $$(4c[i],4w[i])$$ ；...； $$(2^kc[i],2^kw[i]);...$$ 的物品，这些物品最多只能选一次。这其实是十进制数$n$到二进制数的转换，二进制数正好对应对单个物品的取/不取。最终拆分为 $$log(n)$$ 件子物品。

## 完全背包问题

### 问题定义

有 $$N$$ 种物品和容量为 $$V$$ 的背包，第 $$i$$ 个物品的代价是 $$c[i]$$ ，价值是 $$w[i]$$ ，每个物品能装入无限次，求解装入那些物品总价值最大。

### 状态转移方程

**（非01背包思路）**等价于放入 $$[0...k]$$ 个物品 $$i$$ 所能得到的价值的最大值：

$$
f[i][j]=max\{f[i-1][j-k*c[i]]+k*w[i]\quad|\quad 0\leq k*c[i]\leq j\}
$$

**（01背包思路-拆分）**对第 $$i$$ 件物品做选择，当容量剩余为 $$j$$ 时：如果放入第 $$i$$ 件物品，则接下来将考虑 $$[0..i]$$ 件物品放入容量为 $$j-c[i]$$ 的背包中的最大总价值，此时背包中的价值多了 $$w[i]$$ ；如果不放入第 $$i$$ 件物品，则接下来将考虑 $$[0..i-1]$$ 件物品放入容量为 $$j$$ 的背包中的最大总价值。最终取：

$$
f[i][j]=max\{f[i-1][j],f[i][j-c[i]]+w[i]\}
$$

**（01背包思路-二进制拆分）**

### 时间优化

不同于01背包问题，完全背包问题中每种物品可以无限次被选择，所以不需要在计算过程中避开 $$f[i][j]$$ 的结果。与01背包的代码不同在于第二层循环是正向而不是逆向，且完全背包中的两层循环顺序可以颠倒。

```cpp
for i=1...N
    for j=c[i]...V
        f[j] = max{f[j], f[j-c[i]]+w[i]}
```

## 多重背包

### 问题定义

有 $$N$$ 种物品和容量为 $$V$$ 的背包，第 $$i$$ 个物品的代价是 $$c[i]$$ ，价值是 $$w[i]$$ ，最多有 $$n[i]$$ 件可用，求解装入那些物品总价值最大。

### 状态转移方程

**（非01背包思路）**等价于放入 $$[0...k]$$ 个物品 $$i$$ 所能得到的价值的最大值：

$$
f[i][j]=max\{f[i-k][j-k*c[i]]+k*w[i]\quad |\quad 0\leq k\leq n[i]\quad \&\quad 0\leq k*c[i]\leq j\}
$$

**（01背包思路）**

### 伪码

## 混合三种背包

当问题中的物品有的只能取一次、有的能取无限次、有的能取有限次时，根据当前物品的所属的类别选择不同的处理方式即可。

## 二维费用背包

### 问题定义

有 $$N$$ 种物品，和容量为 $$V$$ 和 $$U$$ 的背包，第 $$i$$ 个物品的代价是 $$a[i]$$ 和 $$b[i]$$ ，价值是 $$w[i]$$ ，求解如何装入物品可获得的最大总价值。

### 状态转移方程

$$
f[i][v][u]=max\{f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]\}
$$

降维后：

$$
f[v][u]=max\{f[v][u],f[v-a[i]][u-b[i]]+w[i]\}
$$

## 分组背包

### 问题定义

有 $$N$$ 种物品，和容量为 $$N$$ 的背包，第 $$i$$ 个物品的代价是 $$c[i]$$ ，价值是 $$w[i]$$ 。这些物品被划分为若干个组，每个组中的物品互相冲突，最多只能选一件，求解如何装入物品可获得的最大总价值。

### 状态转移方程

$$
f[k][j]=max\{f[k-1][j],\quad f[k-1][j-c[i]]+w[i]\quad |\quad i\in group_k\}
$$

降维后：

$$
f[j]=max\{f[j],\quad f[j-c[i]]+w[i]\quad |\quad i\in group_k\}
$$

### 伪码

```cpp
for group_k in groups
    for j=V...0
        for i in group_k
            f[j] = max{f[j], f[j-c[i]]+w[i]}
```

注意伪码中第二层和第三层循环顺序一定不能调换，否则就多次使用到了同一组中物品的值。

## 参考资源

背包问题九讲：[https://www.kancloud.cn/kancloud/pack/70124](https://www.kancloud.cn/kancloud/pack/70124)

