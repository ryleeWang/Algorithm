# 二叉树特例

## 二叉搜索树

## 平衡二叉树（balanced binary tree）

### AVL-tree

别称：高度平衡树

平衡因子（balance factor）：某个结点的左子树深度减去右子树深度的差值

#### 性质：

* 从任何一个结点出发，左右子树深度之差（平衡因子）的绝对值不超过1。
* 左右子树仍然为平衡二叉树。

![AVL&#x6811;&#x793A;&#x4F8B;](../.gitbook/assets/avl%20%281%29.png)

#### 缺点

*  删除：对于平衡二叉树来说，在最坏情况下，需要维护从被删结点到根结点这条路径上所有结点的平衡性，旋转的量级是 $$O(logN)$$ 。
*  保持平衡：平衡二叉树高度平衡，这也就意味着在大量插入和删除结点的场景下，平衡二叉树为了保持平衡需要调整的频率会更高。

### RB-tree（红黑树）

{% hint style="info" %}
红黑树中的叶子结点指的是树末尾的NULL，而不是最末尾的有效值。
{% endhint %}

#### 性质

1. 每个结点都是红色或者黑色。
2. 根结点是黑色。
3. 所有叶子结点都是黑色。
4. 如果一个结点是红色，其儿子结点必须是黑色。
5. 对于任一结点而言，其到叶结点的每一条路径都包含相同数目的黑色结点。

可知，新插入的结点必须为红色（不违背性质4），且其父结点必须为黑色（可能会违背性质2，4），如果新结点按照二叉搜索树的规则到达插入点时违反了规则，就要旋转树形并调整颜色。

#### 插入调整

1. 插入结点的父结点为红色，叔叔结点为红色
2. 插入结点的父结点为红色，叔叔结点为黑色
   1. 父结点是祖父结点的左孩子，插入结点是父结点的左孩子（LL）
   2. 父结点是祖父结点的左孩子，插入结点是父结点的右孩子（LR）
   3. 父结点是祖父结点的右孩子，插入结点是父结点的左孩子（RL）
   4. 父结点是祖父结点的右孩子，插入结点是父结点的右孩子（RR）

{% hint style="info" %}
第二种情况调整方法与AVL树思想相同
{% endhint %}

例1，针对第一种情况：

![&#x63D2;&#x5165;&#x7ED3;&#x70B9;&#x2018;0021&#x2019;&#xFF0C;&#x5176;&#x7236;&#x7ED3;&#x70B9;&#x2018;0020&#x2019;&#x4E3A;&#x7EA2;&#x8272;&#xFF0C;&#x53D4;&#x53D4;&#x7ED3;&#x70B9;&#x2018;0038&#x2019;&#x4E3A;&#x9ED1;&#x8272;](../.gitbook/assets/image%20%2810%29.png)

![&#x5C06;&#x2019;0022&#x2018;&#x7684;&#x9ED1;&#x8272;&#x5411;&#x4E0B;&#x4F20;&#x9012;&#xFF0C;&#x4F46;&#x6B64;&#x65F6;&#x2019;0022&#x2018;&#x7684;&#x7EA2;&#x8272;&#x4E0E;&#x2019;0020&#x2018;&#x7684;&#x7EA2;&#x8272;&#x4EA7;&#x751F;&#x77DB;&#x76FE;](../.gitbook/assets/image%20%288%29.png)

![&#x2019;0022&#x2018;&#x662F;&#x7EA2;&#x8272;&#xFF0C;&#x7236;&#x7ED3;&#x70B9;&#x2019;0020&#x2018;&#x662F;&#x7EA2;&#x8272;&#xFF0C;&#x53D4;&#x53D4;&#x8282;&#x70B9;&#x2019;0006&#x2018;&#x662F;&#x7EA2;&#x8272;&#xFF0C;&#x5C06;&#x2019;0015&#x2018;&#x7684;&#x9ED1;&#x8272;&#x5411;&#x4E0B;&#x4F20;&#x9012;](../.gitbook/assets/image%20%2812%29.png)

![&#x4E0A;&#x4E00;&#x6B65;&#x4E2D;&#xFF0C;&#x521A;&#x597D;&#x628A;&#x6839;&#x8282;&#x70B9;&apos;0015&apos;&#x7684;&#x989C;&#x8272;&#x5411;&#x4E0B;&#x4F20;&#x9012;&#x4E86;&#xFF0C;&#x6240;&#x4EE5;&#x8FD8;&#x8981;&#x589E;&#x52A0;&#x4E00;&#x6B65;&#x8BBE;&#x7F6E;&#x2019;0015&#x2018;&#x4E3A;&#x9ED1;&#x8272;](../.gitbook/assets/image%20%289%29.png)

例2，针对第二种情况：

![&#x63D2;&#x5165;&#x7ED3;&#x70B9;&#x2018;0013&#x2019;&#xFF0C;&#x5176;&#x7236;&#x7ED3;&#x70B9;&#x2018;0011&#x2019;&#x4E3A;&#x7EA2;&#x8272;&#xFF0C;&#x53D4;&#x53D4;&#x7ED3;&#x70B9;&#x2018;0001&#x2019;&#x4E3A;&#x9ED1;&#x8272;&#xFF0C;&#x2018;0013&#x2019;&#x662F;&#x2019;0011&#x2018;&#x7684;&#x53F3;&#x5B69;&#x5B50;](../.gitbook/assets/image%20%2811%29.png)

![&#x7ED3;&#x70B9;&#x2019;0008&#x2018;&#x5DE6;&#x65CB;&#xFF0C;&#x5373;&#x2019;0011&#x2018;&#x66FF;&#x6362;&#x5230;&#x2019;0008&#x2018;&#x7684;&#x4F4D;&#x7F6E;&#xFF0C;&#x2019;0008&#x2018;&#x6210;&#x4E3A;&#x5176;&#x5DE6;&#x5B69;&#x5B50;](../.gitbook/assets/image%20%285%29.png)

例3，针对第三种情况：

![&#x63D2;&#x5165;&#x7ED3;&#x70B9;&#x2018;0010&#x2019;&#xFF0C;&#x5176;&#x7236;&#x7ED3;&#x70B9;&#x2018;0011&#x2019;&#x4E3A;&#x7EA2;&#x8272;&#xFF0C;&#x53D4;&#x53D4;&#x7ED3;&#x70B9;NULL&#x4E3A;&#x9ED1;&#x8272;&#xFF0C;&#x2019;0010&#x2018;&#x662F;&#x2019;0011&#x2018;&#x7684;&#x5DE6;&#x5B69;&#x5B50;](../.gitbook/assets/image%20%282%29.png)

![&#x7ED3;&#x70B9;&#x2019;0011&#x2018;&#x53F3;&#x65CB;&#xFF0C;&#x6210;&#x4E3A;&#x7B2C;&#x4E8C;&#x79CD;&#x60C5;&#x51B5;](../.gitbook/assets/image%20%286%29.png)

![&#x7ED3;&#x70B9;&#x2019;0008&#x2018;&#x5DE6;&#x65CB;](../.gitbook/assets/image%20%283%29.png)

### AA-tree

## 堆

适用于快速找到最大值/最小值的题。

## B / B+ 树

## Trie 树（字典树）

## 哈夫曼树（Huffman coding tree）

